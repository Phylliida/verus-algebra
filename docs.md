# API Reference

*Auto-generated by verus-docgenerator*

## `convex`

### Spec Functions

- **`open spec fn two`** — [convex/mod.rs:14](./src/convex/mod.rs#L14)
  > The element 1 + 1.
- **`open spec fn midpoint`** — [convex/mod.rs:19](./src/convex/mod.rs#L19)
  > Midpoint of two elements: (a + b) / 2.
- **`open spec fn convex`** — [convex/mod.rs:24](./src/convex/mod.rs#L24)
  > Convex combination: t*a + (1-t)*b.

### Proof Functions

- **`proof fn lemma_two_nonzero`** — [convex/mod.rs:29](./src/convex/mod.rs#L29)
  > two() ≢ 0.
- **`proof fn lemma_midpoint_self`** — [convex/mod.rs:44](./src/convex/mod.rs#L44)
  > midpoint(a, a) ≡ a.
- **`proof fn lemma_midpoint_commutative`** — [convex/mod.rs:125](./src/convex/mod.rs#L125)
  > midpoint(a, b) ≡ midpoint(b, a).
- **`proof fn lemma_midpoint_between`** — [convex/mod.rs:151](./src/convex/mod.rs#L151)
  > a ≤ b implies a ≤ midpoint(a, b) ≤ b.
- **`proof fn lemma_convex_at_zero`** — [convex/mod.rs:204](./src/convex/mod.rs#L204)
  > convex(a, b, 0) ≡ b.
- **`proof fn lemma_convex_at_one`** — [convex/mod.rs:239](./src/convex/mod.rs#L239)
  > convex(a, b, 1) ≡ a.
- **`proof fn lemma_convex_self`** — [convex/mod.rs:268](./src/convex/mod.rs#L268)
  > convex(a, a, t) ≡ a.
- **`proof fn lemma_convex_complement`** — [convex/mod.rs:302](./src/convex/mod.rs#L302)
  > convex(a, b, t) ≡ convex(b, a, 1-t).
- **`proof fn lemma_convex_bounds`** — [convex/mod.rs:388](./src/convex/mod.rs#L388)
  > a ≤ b and 0 ≤ t ≤ 1 implies a ≤ convex(a, b, t) ≤ b.

## `inequalities`

### Spec Functions

- **`open spec fn abs`** — [inequalities/mod.rs:14](./src/inequalities/mod.rs#L14)
  > Absolute value: returns a if a ≥ 0, otherwise -a.
- **`open spec fn signum`** — [inequalities/mod.rs:482](./src/inequalities/mod.rs#L482)
  > Signum function: returns 1 if a > 0, -1 if a < 0, 0 if a ≡ 0.

### Proof Functions

- **`proof fn lemma_nonneg_add`** — [inequalities/mod.rs:19](./src/inequalities/mod.rs#L19)
  > 0 ≤ a and 0 ≤ b implies 0 ≤ a + b.
- **`proof fn lemma_abs_nonneg`** — [inequalities/mod.rs:33](./src/inequalities/mod.rs#L33)
  > 0 ≤ abs(a).
- **`proof fn lemma_abs_zero`** — [inequalities/mod.rs:47](./src/inequalities/mod.rs#L47)
  > abs(0) ≡ 0.
- **`proof fn lemma_abs_neg`** — [inequalities/mod.rs:56](./src/inequalities/mod.rs#L56)
  > abs(-a) ≡ abs(a).
- **`proof fn lemma_abs_mul`** — [inequalities/mod.rs:84](./src/inequalities/mod.rs#L84)
  > abs(a * b) ≡ abs(a) * abs(b) for OrderedField.
- **`proof fn lemma_triangle_inequality`** — [inequalities/mod.rs:156](./src/inequalities/mod.rs#L156)
  > Triangle inequality: abs(a + b) ≤ abs(a) + abs(b).
- **`proof fn lemma_sum_squares_nonneg_2d`** — [inequalities/mod.rs:270](./src/inequalities/mod.rs#L270)
  > 0 ≤ a*a + b*b.
- **`proof fn lemma_sum_squares_nonneg_3d`** — [inequalities/mod.rs:280](./src/inequalities/mod.rs#L280)
  > 0 ≤ a*a + b*b + c*c.
- **`proof fn lemma_abs_eqv`** — [inequalities/mod.rs:290](./src/inequalities/mod.rs#L290)
  > a ≡ b implies abs(a) ≡ abs(b).
- **`proof fn lemma_abs_sub_symmetric`** — [inequalities/mod.rs:316](./src/inequalities/mod.rs#L316)
  > abs(a - b) ≡ abs(b - a).
- **`proof fn lemma_abs_le_iff`** — [inequalities/mod.rs:330](./src/inequalities/mod.rs#L330)
  > 0 ≤ b implies: abs(a) ≤ b if and only if b.neg() ≤ a and a ≤ b.
- **`proof fn lemma_reverse_triangle`** — [inequalities/mod.rs:376](./src/inequalities/mod.rs#L376)
  > abs(abs(a) - abs(b)) ≤ abs(a - b)   (reverse triangle inequality).
- **`proof fn lemma_signum_pos`** — [inequalities/mod.rs:489](./src/inequalities/mod.rs#L489)
  > 0 < a implies signum(a) ≡ 1.
- **`proof fn lemma_signum_neg`** — [inequalities/mod.rs:499](./src/inequalities/mod.rs#L499)
  > a < 0 implies signum(a) ≡ -1.
- **`proof fn lemma_signum_zero`** — [inequalities/mod.rs:511](./src/inequalities/mod.rs#L511)
  > signum(0) ≡ 0.
- **`proof fn lemma_signum_neg_flip`** — [inequalities/mod.rs:520](./src/inequalities/mod.rs#L520)
  > signum(-a) ≡ -signum(a).
- **`proof fn lemma_signum_abs`** — [inequalities/mod.rs:607](./src/inequalities/mod.rs#L607)
  > signum(a) * abs(a) ≡ a.
- **`proof fn lemma_signum_mul`** — [inequalities/mod.rs:653](./src/inequalities/mod.rs#L653)
  > signum(a*b) ≡ signum(a) * signum(b) (for OrderedField).
- **`proof fn lemma_am_gm`** — [inequalities/mod.rs:772](./src/inequalities/mod.rs#L772)
  > AM-GM inequality: 0 ≤ a and 0 ≤ b implies a*b ≤ (a*a + b*b) / two().
- **`proof fn lemma_abs_mul_self`** — [inequalities/mod.rs:895](./src/inequalities/mod.rs#L895)
  > abs(a) * abs(a) ≡ a * a.
- **`proof fn lemma_abs_pos_iff`** — [inequalities/mod.rs:911](./src/inequalities/mod.rs#L911)
  > 0 < abs(a) if and only if ¬(a ≡ 0).

## `lemmas::additive_commutative_monoid_lemmas`

### Proof Functions

- **`proof fn lemma_add_zero_left`** — [lemmas/additive_commutative_monoid_lemmas.rs:8](./src/lemmas/additive_commutative_monoid_lemmas.rs#L8)
  > Left identity: 0 + a ≡ a. Derived from right identity + commutativity.
- **`proof fn lemma_add_congruence_right`** — [lemmas/additive_commutative_monoid_lemmas.rs:20](./src/lemmas/additive_commutative_monoid_lemmas.rs#L20)
  > Addition respects equivalence on the right: if b ≡ c then a + b ≡ a + c. Derived from commutativity + left congruence.
- **`proof fn lemma_add_congruence`** — [lemmas/additive_commutative_monoid_lemmas.rs:35](./src/lemmas/additive_commutative_monoid_lemmas.rs#L35)
  > Full addition congruence: if a1 ≡ a2 and b1 ≡ b2 then a1 + b1 ≡ a2 + b2.

## `lemmas::additive_group_lemmas`

### Proof Functions

- **`proof fn lemma_add_zero_left`** — [lemmas/additive_group_lemmas.rs:9](./src/lemmas/additive_group_lemmas.rs#L9)
  > Left identity: 0 + a ≡ a. Derived from right identity + commutativity.
- **`proof fn lemma_add_inverse_left`** — [lemmas/additive_group_lemmas.rs:18](./src/lemmas/additive_group_lemmas.rs#L18)
  > Left inverse: (-a) + a ≡ 0. Derived from right inverse + commutativity.
- **`proof fn lemma_add_congruence_right`** — [lemmas/additive_group_lemmas.rs:30](./src/lemmas/additive_group_lemmas.rs#L30)
  > Addition respects equivalence on the right: if b ≡ c then a + b ≡ a + c. Derived from commutativity + left congruence.
- **`proof fn lemma_add_congruence`** — [lemmas/additive_group_lemmas.rs:40](./src/lemmas/additive_group_lemmas.rs#L40)
  > Full addition congruence: if a1 ≡ a2 and b1 ≡ b2 then a1 + b1 ≡ a2 + b2.
- **`proof fn lemma_add_right_cancel`** — [lemmas/additive_group_lemmas.rs:51](./src/lemmas/additive_group_lemmas.rs#L51)
  > Right cancellation: if a + k ≡ b + k then a ≡ b.
- **`proof fn lemma_add_left_cancel`** — [lemmas/additive_group_lemmas.rs:88](./src/lemmas/additive_group_lemmas.rs#L88)
  > Left cancellation: if k + a ≡ k + b then a ≡ b.
- **`proof fn lemma_neg_involution`** — [lemmas/additive_group_lemmas.rs:106](./src/lemmas/additive_group_lemmas.rs#L106)
  > Double negation: -(-a) ≡ a.
- **`proof fn lemma_neg_zero`** — [lemmas/additive_group_lemmas.rs:126](./src/lemmas/additive_group_lemmas.rs#L126)
  > Negation of zero: -0 ≡ 0.
- **`proof fn lemma_sub_self`** — [lemmas/additive_group_lemmas.rs:144](./src/lemmas/additive_group_lemmas.rs#L144)
  > a - a ≡ 0.
- **`proof fn lemma_sub_congruence`** — [lemmas/additive_group_lemmas.rs:154](./src/lemmas/additive_group_lemmas.rs#L154)
  > Full subtraction congruence: if a1 ≡ a2 and b1 ≡ b2 then a1 - b1 ≡ a2 - b2.
- **`proof fn lemma_add_then_sub_cancel`** — [lemmas/additive_group_lemmas.rs:177](./src/lemmas/additive_group_lemmas.rs#L177)
  > (a + b) - b ≡ a.
- **`proof fn lemma_sub_then_add_cancel`** — [lemmas/additive_group_lemmas.rs:198](./src/lemmas/additive_group_lemmas.rs#L198)
  > (a - b) + b ≡ a.
- **`proof fn lemma_neg_add`** — [lemmas/additive_group_lemmas.rs:220](./src/lemmas/additive_group_lemmas.rs#L220)
  > -(a + b) ≡ (-a) + (-b).
- **`proof fn lemma_sub_antisymmetric`** — [lemmas/additive_group_lemmas.rs:317](./src/lemmas/additive_group_lemmas.rs#L317)
  > a - b ≡ -(b - a).
- **`proof fn lemma_sub_eqv_zero_implies_eqv`** — [lemmas/additive_group_lemmas.rs:349](./src/lemmas/additive_group_lemmas.rs#L349)
  > a - b ≡ 0 implies a ≡ b.
- **`proof fn lemma_eqv_implies_sub_eqv_zero`** — [lemmas/additive_group_lemmas.rs:368](./src/lemmas/additive_group_lemmas.rs#L368)
  > a ≡ b implies a - b ≡ 0.
- **`proof fn lemma_sub_neg_both`** — [lemmas/additive_group_lemmas.rs:382](./src/lemmas/additive_group_lemmas.rs#L382)
  > (-a) - (-b) ≡ b - a.
- **`proof fn lemma_add_rearrange_2x2`** — [lemmas/additive_group_lemmas.rs:403](./src/lemmas/additive_group_lemmas.rs#L403)
  > (a + b) + (c + d) ≡ (a + c) + (b + d).
- **`proof fn lemma_add_identity_unique`** — [lemmas/additive_group_lemmas.rs:449](./src/lemmas/additive_group_lemmas.rs#L449)
  > If a + e ≡ a for all a (witnessed by a=0), then e ≡ 0. Specifically: 0 + e ≡ 0 implies e ≡ 0.
- **`proof fn lemma_neg_unique`** — [lemmas/additive_group_lemmas.rs:464](./src/lemmas/additive_group_lemmas.rs#L464)
  > If a + b ≡ 0, then b ≡ -a.

## `lemmas::field_lemmas`

### Proof Functions

- **`proof fn lemma_mul_recip_left`** — [lemmas/field_lemmas.rs:9](./src/lemmas/field_lemmas.rs#L9)
  > Left multiplicative inverse: recip(a) * a ≡ 1 for nonzero a.
- **`proof fn lemma_div_self`** — [lemmas/field_lemmas.rs:21](./src/lemmas/field_lemmas.rs#L21)
  > Division by self: a / a ≡ 1 for nonzero a.
- **`proof fn lemma_nonzero_product`** — [lemmas/field_lemmas.rs:33](./src/lemmas/field_lemmas.rs#L33)
  > If a ≢ 0 and b ≢ 0 then a*b ≢ 0.
- **`proof fn lemma_mul_cancel_right`** — [lemmas/field_lemmas.rs:70](./src/lemmas/field_lemmas.rs#L70)
  > Right cancellation: a*c ≡ b*c and c ≢ 0 implies a ≡ b.
- **`proof fn lemma_mul_cancel_left`** — [lemmas/field_lemmas.rs:103](./src/lemmas/field_lemmas.rs#L103)
  > Left cancellation: c*a ≡ c*b and c ≢ 0 implies a ≡ b.
- **`proof fn lemma_div_one`** — [lemmas/field_lemmas.rs:121](./src/lemmas/field_lemmas.rs#L121)
  > a / 1 ≡ a.
- **`proof fn lemma_recip_involution`** — [lemmas/field_lemmas.rs:149](./src/lemmas/field_lemmas.rs#L149)
  > recip(recip(a)) ≡ a for nonzero a.
- **`proof fn lemma_div_mul_cancel`** — [lemmas/field_lemmas.rs:187](./src/lemmas/field_lemmas.rs#L187)
  > (a / b) * b ≡ a for nonzero b.
- **`proof fn lemma_mul_div_cancel`** — [lemmas/field_lemmas.rs:212](./src/lemmas/field_lemmas.rs#L212)
  > (a * b) / b ≡ a for nonzero b.
- **`proof fn lemma_div_distributes_over_add`** — [lemmas/field_lemmas.rs:235](./src/lemmas/field_lemmas.rs#L235)
  > (a + b) / c ≡ a/c + b/c for nonzero c.
- **`proof fn lemma_recip_mul`** — [lemmas/field_lemmas.rs:266](./src/lemmas/field_lemmas.rs#L266)
  > recip(a * b) ≡ recip(a) * recip(b) for nonzero a, b.
- **`proof fn lemma_recip_neg`** — [lemmas/field_lemmas.rs:350](./src/lemmas/field_lemmas.rs#L350)
  > recip(-a) ≡ -recip(a) for nonzero a.
- **`proof fn lemma_div_div`** — [lemmas/field_lemmas.rs:388](./src/lemmas/field_lemmas.rs#L388)
  > (a / b) / c ≡ a / (b * c) for nonzero b, c.
- **`proof fn lemma_recip_unique`** — [lemmas/field_lemmas.rs:436](./src/lemmas/field_lemmas.rs#L436)
  > If a ≢ 0 and a*b ≡ 1, then b ≡ recip(a).
- **`proof fn lemma_div_neg_numerator`** — [lemmas/field_lemmas.rs:453](./src/lemmas/field_lemmas.rs#L453)
  > (-a)/b ≡ -(a/b) for nonzero b.
- **`proof fn lemma_div_neg_denominator`** — [lemmas/field_lemmas.rs:487](./src/lemmas/field_lemmas.rs#L487)
  > a/(-b) ≡ -(a/b) for nonzero b.
- **`proof fn lemma_div_mul_div`** — [lemmas/field_lemmas.rs:523](./src/lemmas/field_lemmas.rs#L523)
  > (a/b) * (c/d) ≡ (a*c)/(b*d) for nonzero b, d.

## `lemmas::ordered_field_lemmas`

### Proof Functions

- **`proof fn lemma_mul_pos_pos`** — [lemmas/ordered_field_lemmas.rs:11](./src/lemmas/ordered_field_lemmas.rs#L11)
  > 0 < a and 0 < b implies 0 < a*b.
- **`proof fn lemma_mul_neg_neg`** — [lemmas/ordered_field_lemmas.rs:36](./src/lemmas/ordered_field_lemmas.rs#L36)
  > a < 0 and b < 0 implies 0 < a*b.
- **`proof fn lemma_mul_pos_neg`** — [lemmas/ordered_field_lemmas.rs:94](./src/lemmas/ordered_field_lemmas.rs#L94)
  > 0 < a and b < 0 implies a*b < 0.
- **`proof fn lemma_recip_pos`** — [lemmas/ordered_field_lemmas.rs:152](./src/lemmas/ordered_field_lemmas.rs#L152)
  > 0 < a implies 0 < recip(a).
- **`proof fn lemma_recip_reverses_le_pos`** — [lemmas/ordered_field_lemmas.rs:195](./src/lemmas/ordered_field_lemmas.rs#L195)
  > 0 < a ≤ b implies recip(b) ≤ recip(a).
- **`proof fn lemma_recip_reverses_lt_pos`** — [lemmas/ordered_field_lemmas.rs:297](./src/lemmas/ordered_field_lemmas.rs#L297)
  > 0 < a < b implies recip(b) < recip(a).
- **`proof fn lemma_le_div_monotone`** — [lemmas/ordered_field_lemmas.rs:352](./src/lemmas/ordered_field_lemmas.rs#L352)
  > a ≤ b and 0 < c implies a/c ≤ b/c.
- **`proof fn lemma_mul_le_cancel_pos`** — [lemmas/ordered_field_lemmas.rs:375](./src/lemmas/ordered_field_lemmas.rs#L375)
  > 0 < c and a*c ≤ b*c implies a ≤ b.
- **`proof fn lemma_cross_mul_le`** — [lemmas/ordered_field_lemmas.rs:401](./src/lemmas/ordered_field_lemmas.rs#L401)
  > 0 < b and 0 < d implies: a/b ≤ c/d if and only if a*d ≤ c*b.

## `lemmas::ordered_ring_lemmas`

### Proof Functions

- **`proof fn lemma_lt_irreflexive`** — [lemmas/ordered_ring_lemmas.rs:10](./src/lemmas/ordered_ring_lemmas.rs#L10)
  > Strict order is irreflexive: !(a < a).
- **`proof fn lemma_lt_asymmetric`** — [lemmas/ordered_ring_lemmas.rs:19](./src/lemmas/ordered_ring_lemmas.rs#L19)
  > Strict order is asymmetric: a < b implies !(b < a).
- **`proof fn lemma_lt_transitive`** — [lemmas/ordered_ring_lemmas.rs:36](./src/lemmas/ordered_ring_lemmas.rs#L36)
  > Strict order is transitive: a < b && b < c implies a < c.
- **`proof fn lemma_le_add_compatible`** — [lemmas/ordered_ring_lemmas.rs:63](./src/lemmas/ordered_ring_lemmas.rs#L63)
  > a <= b implies a + c <= b + c (restated for convenience; same as axiom).
- **`proof fn lemma_lt_add_compatible`** — [lemmas/ordered_ring_lemmas.rs:73](./src/lemmas/ordered_ring_lemmas.rs#L73)
  > a < b implies a + c < b + c.
- **`proof fn lemma_nonneg_mul_nonneg`** — [lemmas/ordered_ring_lemmas.rs:90](./src/lemmas/ordered_ring_lemmas.rs#L90)
  > 0 <= a and 0 <= b implies 0 <= a * b.
- **`proof fn lemma_square_nonneg`** — [lemmas/ordered_ring_lemmas.rs:109](./src/lemmas/ordered_ring_lemmas.rs#L109)
  > 0 <= a * a (squares are non-negative).
- **`proof fn lemma_le_iff_lt_or_eqv`** — [lemmas/ordered_ring_lemmas.rs:152](./src/lemmas/ordered_ring_lemmas.rs#L152)
  > a ≤ b if and only if a < b or a ≡ b.
- **`proof fn lemma_le_congruence_left`** — [lemmas/ordered_ring_lemmas.rs:167](./src/lemmas/ordered_ring_lemmas.rs#L167)
  > Single-arg left congruence: a1 ≡ a2 and a1 ≤ b implies a2 ≤ b.
- **`proof fn lemma_le_congruence_right`** — [lemmas/ordered_ring_lemmas.rs:178](./src/lemmas/ordered_ring_lemmas.rs#L178)
  > Single-arg right congruence: a ≤ b1 and b1 ≡ b2 implies a ≤ b2.
- **`proof fn lemma_lt_le_transitive`** — [lemmas/ordered_ring_lemmas.rs:189](./src/lemmas/ordered_ring_lemmas.rs#L189)
  > a < b and b ≤ c implies a < c.
- **`proof fn lemma_le_lt_transitive`** — [lemmas/ordered_ring_lemmas.rs:212](./src/lemmas/ordered_ring_lemmas.rs#L212)
  > a ≤ b and b < c implies a < c.
- **`proof fn lemma_le_neg_flip`** — [lemmas/ordered_ring_lemmas.rs:234](./src/lemmas/ordered_ring_lemmas.rs#L234)
  > a ≤ b implies -b ≤ -a.
- **`proof fn lemma_lt_neg_flip`** — [lemmas/ordered_ring_lemmas.rs:302](./src/lemmas/ordered_ring_lemmas.rs#L302)
  > a < b implies -b < -a.
- **`proof fn lemma_neg_nonneg_iff`** — [lemmas/ordered_ring_lemmas.rs:326](./src/lemmas/ordered_ring_lemmas.rs#L326)
  > 0 ≤ a if and only if -a ≤ 0.
- **`proof fn lemma_neg_nonpos_iff`** — [lemmas/ordered_ring_lemmas.rs:350](./src/lemmas/ordered_ring_lemmas.rs#L350)
  > a ≤ 0 if and only if 0 ≤ -a.
- **`proof fn lemma_le_sub_monotone`** — [lemmas/ordered_ring_lemmas.rs:371](./src/lemmas/ordered_ring_lemmas.rs#L371)
  > a ≤ b implies a - c ≤ b - c.
- **`proof fn lemma_lt_sub_monotone`** — [lemmas/ordered_ring_lemmas.rs:388](./src/lemmas/ordered_ring_lemmas.rs#L388)
  > a < b implies a - c < b - c.
- **`proof fn lemma_trichotomy`** — [lemmas/ordered_ring_lemmas.rs:414](./src/lemmas/ordered_ring_lemmas.rs#L414)
  > Trichotomy: exactly one of a < b, a ≡ b, b < a holds.
- **`proof fn lemma_le_mul_nonneg_both`** — [lemmas/ordered_ring_lemmas.rs:450](./src/lemmas/ordered_ring_lemmas.rs#L450)
  > 0 ≤ a ≤ c and 0 ≤ b ≤ d implies a*b ≤ c*d.
- **`proof fn lemma_zero_lt_one`** — [lemmas/ordered_ring_lemmas.rs:483](./src/lemmas/ordered_ring_lemmas.rs#L483)
  > 0 < 1.
- **`proof fn lemma_add_nonneg_pos`** — [lemmas/ordered_ring_lemmas.rs:500](./src/lemmas/ordered_ring_lemmas.rs#L500)
  > 0 ≤ a and 0 < b implies 0 < a + b.
- **`proof fn lemma_add_pos_nonneg`** — [lemmas/ordered_ring_lemmas.rs:518](./src/lemmas/ordered_ring_lemmas.rs#L518)
  > 0 < a and 0 ≤ b implies 0 < a + b.
- **`proof fn lemma_le_add_both`** — [lemmas/ordered_ring_lemmas.rs:540](./src/lemmas/ordered_ring_lemmas.rs#L540)
  > a ≤ b and c ≤ d implies a + c ≤ b + d.
- **`proof fn lemma_lt_add_both`** — [lemmas/ordered_ring_lemmas.rs:561](./src/lemmas/ordered_ring_lemmas.rs#L561)
  > a < b and c < d implies a + c < b + d.
- **`proof fn lemma_square_le_square`** — [lemmas/ordered_ring_lemmas.rs:592](./src/lemmas/ordered_ring_lemmas.rs#L592)
  > 0 ≤ a ≤ b implies a*a ≤ b*b.

## `lemmas::partial_order_lemmas`

### Proof Functions

- **`proof fn lemma_le_congruence_left`** — [lemmas/partial_order_lemmas.rs:7](./src/lemmas/partial_order_lemmas.rs#L7)
  > Single-arg left congruence: a1 ≡ a2 and a1 ≤ b implies a2 ≤ b.
- **`proof fn lemma_le_congruence_right`** — [lemmas/partial_order_lemmas.rs:19](./src/lemmas/partial_order_lemmas.rs#L19)
  > Single-arg right congruence: a ≤ b1 and b1 ≡ b2 implies a ≤ b2.
- **`proof fn lemma_le_eqv_implies_le`** — [lemmas/partial_order_lemmas.rs:31](./src/lemmas/partial_order_lemmas.rs#L31)
  > a ≡ b implies a ≤ b (from reflexivity + congruence).

## `lemmas::ring_lemmas`

### Proof Functions

- **`proof fn lemma_mul_one_left`** — [lemmas/ring_lemmas.rs:9](./src/lemmas/ring_lemmas.rs#L9)
  > Left identity: 1 * a ≡ a. Derived from right identity + commutativity.
- **`proof fn lemma_mul_zero_left`** — [lemmas/ring_lemmas.rs:20](./src/lemmas/ring_lemmas.rs#L20)
  > Left zero: 0 * a ≡ 0. Derived from right zero + commutativity.
- **`proof fn lemma_mul_distributes_right`** — [lemmas/ring_lemmas.rs:31](./src/lemmas/ring_lemmas.rs#L31)
  > Right distributivity: (a + b) * c ≡ a*c + b*c. Derived from left distributivity + commutativity.
- **`proof fn lemma_mul_congruence_right`** — [lemmas/ring_lemmas.rs:59](./src/lemmas/ring_lemmas.rs#L59)
  > Multiplication respects equivalence on the right: if b ≡ c then a * b ≡ a * c.
- **`proof fn lemma_mul_congruence`** — [lemmas/ring_lemmas.rs:74](./src/lemmas/ring_lemmas.rs#L74)
  > Full multiplication congruence: if a1 ≡ a2 and b1 ≡ b2 then a1*b1 ≡ a2*b2.
- **`proof fn lemma_mul_neg_one`** — [lemmas/ring_lemmas.rs:87](./src/lemmas/ring_lemmas.rs#L87)
  > Multiplication by -1: (-1) * a ≡ -a.
- **`proof fn lemma_mul_neg_right`** — [lemmas/ring_lemmas.rs:157](./src/lemmas/ring_lemmas.rs#L157)
  > a * (-b) ≡ -(a * b).
- **`proof fn lemma_mul_neg_left`** — [lemmas/ring_lemmas.rs:203](./src/lemmas/ring_lemmas.rs#L203)
  > (-a) * b ≡ -(a * b).
- **`proof fn lemma_neg_mul_neg`** — [lemmas/ring_lemmas.rs:218](./src/lemmas/ring_lemmas.rs#L218)
  > (-a) * (-b) ≡ a * b.
- **`proof fn lemma_mul_distributes_over_sub`** — [lemmas/ring_lemmas.rs:245](./src/lemmas/ring_lemmas.rs#L245)
  > a * (b - c) ≡ a*b - a*c.
- **`proof fn lemma_sub_mul_right`** — [lemmas/ring_lemmas.rs:276](./src/lemmas/ring_lemmas.rs#L276)
  > (a - b) * k ≡ a*k - b*k.
- **`proof fn lemma_mul_two`** — [lemmas/ring_lemmas.rs:299](./src/lemmas/ring_lemmas.rs#L299)
  > a + a ≡ (1 + 1) * a.
- **`proof fn lemma_square_sub`** — [lemmas/ring_lemmas.rs:327](./src/lemmas/ring_lemmas.rs#L327)
  > (a - b) * (a + b) ≡ a*a - b*b.
- **`proof fn lemma_square_expand`** — [lemmas/ring_lemmas.rs:468](./src/lemmas/ring_lemmas.rs#L468)
  > (a + b) * (a + b) ≡ a*a + (1+1)*a*b + b*b.
- **`proof fn lemma_square_sub_expand`** — [lemmas/ring_lemmas.rs:573](./src/lemmas/ring_lemmas.rs#L573)
  > (a - b) * (a - b) ≡ a*a - (1+1)*a*b + b*b.
- **`proof fn lemma_mul_identity_unique`** — [lemmas/ring_lemmas.rs:647](./src/lemmas/ring_lemmas.rs#L647)
  > If 1 * e ≡ 1, then e ≡ 1.

## `min_max`

### Spec Functions

- **`open spec fn min`** — [min_max/mod.rs:10](./src/min_max/mod.rs#L10)
  > Minimum of two elements.
- **`open spec fn max`** — [min_max/mod.rs:15](./src/min_max/mod.rs#L15)
  > Maximum of two elements.

### Proof Functions

- **`proof fn lemma_min_le_left`** — [min_max/mod.rs:20](./src/min_max/mod.rs#L20)
  > min(a, b) ≤ a.
- **`proof fn lemma_min_le_right`** — [min_max/mod.rs:34](./src/min_max/mod.rs#L34)
  > min(a, b) ≤ b.
- **`proof fn lemma_max_ge_left`** — [min_max/mod.rs:48](./src/min_max/mod.rs#L48)
  > a ≤ max(a, b).
- **`proof fn lemma_max_ge_right`** — [min_max/mod.rs:62](./src/min_max/mod.rs#L62)
  > b ≤ max(a, b).
- **`proof fn lemma_min_commutative`** — [min_max/mod.rs:76](./src/min_max/mod.rs#L76)
  > min(a, b) ≡ min(b, a).
- **`proof fn lemma_max_commutative`** — [min_max/mod.rs:99](./src/min_max/mod.rs#L99)
  > max(a, b) ≡ max(b, a).
- **`proof fn lemma_min_le_max`** — [min_max/mod.rs:122](./src/min_max/mod.rs#L122)
  > min(a, b) ≤ max(a, b).
- **`proof fn lemma_min_max_sum`** — [min_max/mod.rs:135](./src/min_max/mod.rs#L135)
  > min(a, b) + max(a, b) ≡ a + b.
- **`proof fn lemma_min_self`** — [min_max/mod.rs:151](./src/min_max/mod.rs#L151)
  > min(a, a) ≡ a.
- **`proof fn lemma_max_self`** — [min_max/mod.rs:160](./src/min_max/mod.rs#L160)
  > max(a, a) ≡ a.
- **`proof fn lemma_min_associative`** — [min_max/mod.rs:169](./src/min_max/mod.rs#L169)
  > min(min(a,b),c) ≡ min(a,min(b,c)).
- **`proof fn lemma_max_associative`** — [min_max/mod.rs:224](./src/min_max/mod.rs#L224)
  > max(max(a,b),c) ≡ max(a,max(b,c)).
- **`proof fn lemma_min_le_iff`** — [min_max/mod.rs:271](./src/min_max/mod.rs#L271)
  > min(a,b) ≤ c if and only if a ≤ c or b ≤ c.
- **`proof fn lemma_max_le_iff`** — [min_max/mod.rs:298](./src/min_max/mod.rs#L298)
  > c ≤ max(a,b) if and only if c ≤ a or c ≤ b.
- **`proof fn lemma_min_neg`** — [min_max/mod.rs:324](./src/min_max/mod.rs#L324)
  > min(a,b).neg() ≡ max(a.neg(), b.neg()).

## `number_theory`

### Spec Functions

- **`open spec fn divides`** — [number_theory/mod.rs:9](./src/number_theory/mod.rs#L9)
  > a divides b if there exists k such that a * k ≡ b.

### Proof Functions

- **`proof fn lemma_divides_reflexive`** — [number_theory/mod.rs:14](./src/number_theory/mod.rs#L14)
  > Every element divides itself: divides(a, a), witness: one().
- **`proof fn lemma_divides_zero`** — [number_theory/mod.rs:23](./src/number_theory/mod.rs#L23)
  > Every element divides zero: divides(a, 0), witness: zero().
- **`proof fn lemma_one_divides`** — [number_theory/mod.rs:32](./src/number_theory/mod.rs#L32)
  > One divides everything: divides(1, a), witness: a.
- **`proof fn lemma_divides_transitive`** — [number_theory/mod.rs:41](./src/number_theory/mod.rs#L41)
  > Divisibility is transitive: divides(a,b) and divides(b,c) implies divides(a,c).
- **`proof fn lemma_divides_add`** — [number_theory/mod.rs:66](./src/number_theory/mod.rs#L66)
  > If a divides b and a divides c, then a divides b + c.
- **`proof fn lemma_divides_mul_right`** — [number_theory/mod.rs:96](./src/number_theory/mod.rs#L96)
  > If a divides b, then a divides b * c.
- **`proof fn lemma_divides_neg`** — [number_theory/mod.rs:115](./src/number_theory/mod.rs#L115)
  > If a divides b, then a divides -b.

## `power`

### Spec Functions

- **`open spec fn pow`** — [power/mod.rs:13](./src/power/mod.rs#L13)
  > Power function: base^exp.

### Proof Functions

- **`proof fn lemma_pow_zero`** — [power/mod.rs:21](./src/power/mod.rs#L21)
  > pow(a, 0) ≡ 1.
- **`proof fn lemma_pow_one`** — [power/mod.rs:29](./src/power/mod.rs#L29)
  > pow(a, 1) ≡ a.
- **`proof fn lemma_pow_two`** — [power/mod.rs:45](./src/power/mod.rs#L45)
  > pow(a, 2) ≡ a * a.
- **`proof fn lemma_pow_succ`** — [power/mod.rs:57](./src/power/mod.rs#L57)
  > pow(a, n+1) ≡ a * pow(a, n).
- **`proof fn lemma_one_pow`** — [power/mod.rs:65](./src/power/mod.rs#L65)
  > pow(1, n) ≡ 1.
- **`proof fn lemma_zero_pow`** — [power/mod.rs:88](./src/power/mod.rs#L88)
  > n > 0 implies pow(0, n) ≡ 0.
- **`proof fn lemma_pow_add`** — [power/mod.rs:100](./src/power/mod.rs#L100)
  > pow(a, m + n) ≡ pow(a, m) * pow(a, n).
- **`proof fn lemma_pow_mul`** — [power/mod.rs:135](./src/power/mod.rs#L135)
  > pow(a, m * n) ≡ pow(pow(a, m), n).
- **`proof fn lemma_pow_nonneg`** — [power/mod.rs:167](./src/power/mod.rs#L167)
  > 0 ≤ a implies 0 ≤ pow(a, n).
- **`proof fn lemma_pow_monotone`** — [power/mod.rs:185](./src/power/mod.rs#L185)
  > 0 ≤ a ≤ b implies pow(a, n) ≤ pow(b, n).
- **`proof fn lemma_pow_eqv`** — [power/mod.rs:235](./src/power/mod.rs#L235)
  > a ≡ b implies pow(a, n) ≡ pow(b, n).
- **`proof fn lemma_pow_pos`** — [power/mod.rs:254](./src/power/mod.rs#L254)
  > 0 < a implies 0 < pow(a, n) (for OrderedField).
- **`proof fn lemma_pow_mul_base`** — [power/mod.rs:273](./src/power/mod.rs#L273)
  > pow(a*b, n) ≡ pow(a, n) * pow(b, n).
- **`proof fn lemma_pow_neg_one_even`** — [power/mod.rs:362](./src/power/mod.rs#L362)
  > pow((-1), 2*n) ≡ 1.

